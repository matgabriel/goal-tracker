<!DOCTYPE html><html lang="en"><head><title>main/GoalTrackerWidget.spec</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="main/GoalTrackerWidget.spec"><meta name="groc-project-path" content="src/main/GoalTrackerWidget.spec.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/main/GoalTrackerWidget.spec.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="suivi-du-jour-pour-un-objectif-tests">Suivi du jour pour un objectif (tests)</h1></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> { cleanup, fireEvent, render } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cet import enregistre des assertions supplémentaires liées à jest-dom dans le
<code>expect()</code> de Jest, telles que <code>toBeDisabled()</code>, <code>toHaveClass()</code> ou encore
<code>toHaveAttribute()</code>.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> <span class="hljs-string">'@testing-library/jest-dom/extend-expect'</span>

<span class="hljs-keyword">import</span> GoalTrackerWidget <span class="hljs-keyword">from</span> <span class="hljs-string">'./GoalTrackerWidget'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Classiquement, quand on décrit un composant React, on utilise sa balise JSX
comme sujet de la description.  Celui-ci est censé…</p></div></div><div class="code"><div class="wrapper">describe(<span class="hljs-string">'&lt;GoalTrackerWidget /&gt;'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> goal = {
    id: <span class="hljs-string">'0123456789abcdef01234567'</span>,
    name: <span class="hljs-string">'My goal'</span>,
    target: <span class="hljs-number">42</span>,
    units: <span class="hljs-string">'wombats'</span>,
  }

  describe(<span class="hljs-string">'when not completed'</span>, () =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="produire-le-balisage-attendu-pour-un-objectif-non-atteint">…produire le balisage attendu pour un objectif non atteint</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper">    it(<span class="hljs-string">'should render appropriately'</span>, () =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On va tester quatre valeurs pour le taux de complétion: les “bornes” 0,
1 et 41, d’une part, et une valeur quelconque, ici le 21 en plein
milieu, d’autre part.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> progress <span class="hljs-keyword">of</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">21</span>, <span class="hljs-number">41</span>]) {
        <span class="hljs-keyword">const</span> { getByRole, queryByTestId, queryByText } = render(
          <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">GoalTrackerWidget</span> <span class="hljs-attribute">goal</span>=<span class="hljs-value">{goal}</span> <span class="hljs-attribute">progress</span>=<span class="hljs-value">{progress}</span> /&gt;</span>
        )</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Le composant de type titre (h1, h2 ou autre) devrait avoir le nom de
l’objectif comme texte (fut-ce un texte partiel).</p></div></div><div class="code"><div class="wrapper">        expect(getByRole(<span class="hljs-string">'heading'</span>)).toHaveTextContent(goal.name)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Le composant ayant un rôle de barre de progression (créé en interne
par le <code>&lt;LinearProgress/&gt;</code> utilisé par <code>&lt;Gauge/&gt;</code>) devrait avoir la
bonne valeur dans l’attribut ARIA adapté.  C’est plus propre à tester
que les styles en termes de largeur, etc.</p></div></div><div class="code"><div class="wrapper">        expect(getByRole(<span class="hljs-string">'progressbar'</span>)).toHaveAttribute(
          <span class="hljs-string">'aria-valuenow'</span>,
          <span class="hljs-built_in">String</span>(<span class="hljs-built_in">Math</span>.round((progress * <span class="hljs-number">100</span>) / goal.target))
        )</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On devrait trouver quelque part un texte bien précis de
contextualisation.</p>
<p><code>queryByText</code> renvoie soit le composant trouvé, soit <code>null</code>,
contrairement à <code>getByText()</code>, qui lève une exception si le composant
est absent.  On opte ici pour une assertion plus explicite et
descriptive.</p></div></div><div class="code"><div class="wrapper">        expect(
          queryByText(<span class="hljs-string">`<span class="hljs-subst">${progress}</span> <span class="hljs-subst">${goal.units}</span> sur <span class="hljs-subst">${goal.target}</span>`</span>)
        ).not.toBeNull()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Il arrive que certains composants ne puissent pas être ciblés par les
requêtes usuelles de RTL, en raison de l’implémentation des
composants React concernés.  Dans un tel cas, on peut les doter d’une
<em>prop</em> <code>data-testid</code>, qui sert spécifiquement à ça.</p></div></div><div class="code"><div class="wrapper">        expect(queryByTestId(<span class="hljs-string">'in-progress'</span>)).not.toBeNull()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Dans une boucle de <code>render()</code>, il faut penser à bien démonter les
arbos d’un tour à l’autre pour éviter qu’elles ne s’accumulent.</p></div></div><div class="code"><div class="wrapper">        cleanup()
      }
    })</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="-d-clencher-correctement-son-onprogress-au-clic">…déclencher correctement son <code>onProgress</code> au clic</h2></div></div><div class="code"><div class="wrapper">    it(<span class="hljs-string">'should trigger its onProgress on click'</span>, () =&gt; {
      <span class="hljs-keyword">const</span> progress = <span class="hljs-number">21</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Pour vérifier que le <em>callback</em> transmis est bien appelé, rien de tel
qu’un <em>spy</em> fourni par
<a href="https://jestjs.io/docs/en/jest-object#mock-functions">jest.fn()</a>.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">const</span> onProgress = jest.fn()
      <span class="hljs-keyword">const</span> { getByRole } = render(
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">GoalTrackerWidget</span>
          <span class="hljs-attribute">goal</span>=<span class="hljs-value">{goal}</span>
          <span class="hljs-attribute">onProgress</span>=<span class="hljs-value">{onProgress}</span>
          <span class="hljs-attribute">progress</span>=<span class="hljs-value">{progress}</span>
        /&gt;</span>
      )</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On simule le clic.</p></div></div><div class="code"><div class="wrapper">      fireEvent.click(getByRole(<span class="hljs-string">'button'</span>))
      expect(onProgress).toHaveBeenCalledTimes(<span class="hljs-number">1</span>)
      expect(onProgress).toHaveBeenCalledWith(goal)
    })</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="valider-le-snapshot">…valider le snapshot</h2>
<p>(avoir une structure détaillée identique à la dernière qui a été validée
par les développeurs au moyen d’un snapshot.)</p></div></div><div class="code"><div class="wrapper">    it(<span class="hljs-string">'should otherwise match the expected snapshot'</span>, () =&gt; {
      <span class="hljs-keyword">const</span> { container } = render(
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">GoalTrackerWidget</span> <span class="hljs-attribute">goal</span>=<span class="hljs-value">{goal}</span> <span class="hljs-attribute">progress</span>=<span class="hljs-value">{21}</span> /&gt;</span>
      )</span>

      expect(container).toMatchSnapshot()
    })
  })

  describe(<span class="hljs-string">'when completed (or exceeded)'</span>, () =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="produire-le-balisage-attendu-pour-un-objectif-atteint-voire-dpass">…produire le balisage attendu pour un objectif atteint (voire dépassé)</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper">    it(<span class="hljs-string">'should render appropriately'</span>, () =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On va tester trois valeurs de dépassement de l’objectif: la borne zéro
(objectif atteint, pile-poil) et des plus grandes (objectif dépassé).</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> progress <span class="hljs-keyword">of</span> [goal.target, goal.target + <span class="hljs-number">1</span>, goal.target + <span class="hljs-number">10</span>]) {
        <span class="hljs-keyword">const</span> { queryByTestId } = render(
          <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">GoalTrackerWidget</span> <span class="hljs-attribute">goal</span>=<span class="hljs-value">{goal}</span> <span class="hljs-attribute">progress</span>=<span class="hljs-value">{progress}</span> /&gt;</span>
        )</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Si on a atteint ou dépassé l&#39;objectif, on n&#39;est pas censé avoir
l’icône d&#39;ajout qui trahirait un bouton de progression, mais on est
censé avoir l’icône de pouce vers le haut, qui traduit l’objectif (au
moins) atteint.</p></div></div><div class="code"><div class="wrapper">        expect(queryByTestId(<span class="hljs-string">'in-progress'</span>)).toBeNull()
        expect(queryByTestId(<span class="hljs-string">'completed'</span>)).not.toBeNull()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Dans une boucle de <code>render()</code>, il faut penser à bien démonter les
arbos d’un tour à l’autre pour éviter qu’elles ne s’accumulent.</p></div></div><div class="code"><div class="wrapper">        cleanup()
      }
    })</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="valider-le-snapshot">…valider le snapshot</h2>
<p>(avoir une structure détaillée identique à la dernière qui a été validée
par les développeurs au moyen d’un snapshot.)</p></div></div><div class="code"><div class="wrapper">    it(<span class="hljs-string">'should otherwise match the expected snapshot'</span>, () =&gt; {
      <span class="hljs-keyword">const</span> { container } = render(
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">GoalTrackerWidget</span> <span class="hljs-attribute">goal</span>=<span class="hljs-value">{goal}</span> <span class="hljs-attribute">progress</span>=<span class="hljs-value">{42}</span> /&gt;</span>
      )</span>

      expect(container).toMatchSnapshot()
    })
  })
})</div></div></div></div></body></html>